---
title: <center>Algerian Forest Fire Analysis</center><br/>
output: html_notebook
author:
  - Mohamed Rissal Hedna 201906233
  - Younes Djemmal 201906303
---
## Overview
### Background

During the summer of 2012, [wild fires](https://www.un-spider.org/news-and-events/news/algeria-maps-summer-2012-wildfires-available) ravaged throughout the Algerian territory covering most of the northern part, especially the coastal cities. This disaster was due to the higher than average temperatures which reached as high as 50 degrees Celcius.

### Objectives 

One important measure against the reproduction of such disasters is the ability to predict their occurrence. Moreover, in this project, we will attempt to predict these forest fires based on multiple features related to weather indices.

### Dataset Description

The Dataset we will use to train and test our models consists of 244 observations on two Algerian Wilayas (cities): Sidi-Bel Abbes and Bejaia. The observations have been gathered throughout the duration of 4 months from June to September 2012 for both cities.

**The Dataset contains the following variables:**

1. Date: (DD/MM/YYYY) Day, month ('june' to 'september'), year (2012)
2. Temp: temperature noon (temperature max) in Celsius degrees: 22 to 42
3. RH: Relative Humidity in %: 21 to 90
4. Ws: Wind speed in km/h: 6 to 29
5. Rain: total day in mm: 0 to 16.8<br>
**FWI Components (check this [LINK](https://cwfis.cfs.nrcan.gc.ca/background/summary/fwi) for more information)**
6. Fine Fuel Moisture Code (FFMC) index from the FWI system: 28.6 to 92.5
7. Duff Moisture Code (DMC) index from the FWI system: 1.1 to 65.9
8. Drought Code (DC) index from the FWI system: 7 to 220.4
9. Initial Spread Index (ISI) index from the FWI system: 0 to 18.5
10. Build-up Index (BUI) index from the FWI system: 1.1 to 68
11. Fire Weather Index (FWI) Index: 0 to 31.1
12. Classes: two classes, namely "fire" and "not fire"

## Exploratory Data Analysis

We first start off by importing the necessary libraries for our analysis.

[INSERT DESCRIPTION OF EACH LIBRARY]

```{r, include=FALSE}
library(GA)
library(e1071)
library(MASS)
library(dplyr)
library(vtable)
library(plyr)
library(ggplot2)
library(ggcorrplot)
library(plotly)
library(tidyverse)
#Feature selection libraries
library(mlbench)
library(caret)
#For Logistic regression
library(caTools)
#For ROC curve
library(ROCR)
```


### Importing the data 

The Dataset provided to us was in the form of a .csv file that contained two tables, one table for the observations belonging to the Sidi-Bel Abbes region, and the other for Bejaia. 

Before starting our analysis we separated the tables into two distinct files according to the region. We named both files *Algerian_forest_fires_dataset_Bejaia.csv* and *Algerian_forest_fires_dataset_Sidi_Bel_Abbes.csv* for Bejaia and Sidi-Bel Abbes respectively.


```{r, echo=FALSE}
df_b <- read.csv("./Algerian_forest_fires_dataset_Bejaia.csv")
df_s <- read.csv("./Algerian_forest_fires_dataset_Sidi_Bel_Abbes.csv")
```

### Cleaning and processing the data

We first check the existence of null values in the Dataset, none were found.


```{r}
colSums(is.na(df_b))
colSums(is.na(df_s))
```

We then process to add a column in both datasets to indicate the region(Wilaya) in each table. We chose the following encoding:

1. Bejaia = 0
2. Sidi-Bel Abbes = 1


```{r}
df_b[["Region"]] = 0
df_s[["Region"]] = 1
```

After that, we proceed to merge both our datasets into one single dataframe using *full_join()*, this will allow us to easily explore and analyze the data.

```{r}
df_s$DC <- as.double(df_s$DC)
df_s$FWI <- as.double(df_s$FWI)

df = full_join(df_s, df_b)

dim(df)
str(df)
```

```{r}
summary(df)
unique(df$year)
unique(df$month)
```

We check again for any *NA* values that might have been introduced into the dataset by merging the data from both tables, we found out there was one row that contained NA value in DC and FWI. We delete that row since it will not affect our overall dataset.

```{r}
colSums(is.na(df))
df = df %>% drop_na(DC)
dim(df)
```

We now proceed to display the different range of values some categorical variables might contain, mainly the Classes and the Region columns.


```{r}
unique(df$Classes)
unique(df$Region)
```

We find that the Classes column has values that contain unneeded space characters, we proceed to trim those spaces.

```{r}
df$Classes <- trimws(df$Classes, which = c("both"))
```



```{r}
unique(df$Classes)
df = df %>% drop_na(Classes)
```

```{r}
df$Classes <- mapvalues(df$Classes, from=c("not fire","fire"), to=c(0,1))
```

```{r}
unique(df$Classes)
df$Classes <- as.numeric(df$Classes)
st(df)
```

```{r}
df <- df[-c(3)]

df_scaled = df
df_scaled[-c(1,2,13,14)] <- scale(df[-c(1,2,13,14)])
st(df_scaled)

```

### Visualizing the data

We have ended up with a clean and scaled dataframe named *df_scaled*, which we will use to visualize and further explore our data.

Our first instinct is to compare the two regions together in terms of number of fires, and average temperature. 

```{r}
aggregate(df$Classes ~ df$Region, FUN = sum)
aggregate(df$Temperature ~ df$Region, FUN = mean)
```
We used the unscaled dataset to plot the real life values of the temperatures.

```{r}
df %>%
  group_by(Region) %>%
  summarise(Region = Region, Number_of_fires = sum(Classes), Temperature = mean(Temperature)) %>%
  ggplot(aes(x=Region, y=Number_of_fires, fill = Temperature))+
  geom_col(position='dodge')
```

We can see that the the Sidi-Bel Abbes region has in total a greater number of fires and a higher average temperature throughout the summer of 2012.

## Further Analysis
### Correlation Matrix

The previous results push us to suspect a positive relationship between the temperature and the likelihood of having a fire. However, we need to investigate all the other variables, which is why we will plot a correlation matrix of the features in the dataset.

```{r}
corr_mat <- round(cor(df_scaled),2)
p_mat <- cor_pmat(df_scaled)
 
corr_mat <- ggcorrplot(
  corr_mat, 
  hc.order = FALSE, 
  type = "upper",
  outline.col = "white",
)
 
ggplotly(corr_mat)
```

### Feature Selection

We performed feature selection using the Caret package to determine which features are the most important and which are the least. 

In this case, we opted for Linear Discriminant Analysis with Stepwise Feature Selection by specifying *stepLDA* as our method.

The *varImp* function returns a measure of importance out of 100 for each of the features. According to the official [Caret documentation](https://topepo.github.io/caret/variable-importance.html), the importance metric is calculated by conducting a ROC curve analysis on each predictor; a series of cutoffs is applied to the predictor data to predict the class. The AUC is then computed and is used as a measure of variable importance. 


```{r}
# prepare training scheme
df_scaled$Classes = as.factor(df_scaled$Classes)

control <- trainControl(method="repeatedcv", number=10, repeats=3)
# train the model
modelLDA <- train(Classes~., data=df_scaled, method="stepLDA", trControl=control)

importanceLDA <- varImp(modelLDA, scale=FALSE)

plot(importanceLDA)
```
We can see that the variables *month*, *Ws*, *Region*, and *day* are insignificant compared to other features. We will disregard them in our model.



## Model Building

For the following models, we will only use the features that were the most significant in our feature selection phase. The selected features are:

1. Temperature
2. Rain
3. FFMC
4. DMC
5. DC
6. ISI
7. BUI
8. FWI
9. RH

### Splitting the dataset

We begin by splitting the data into train/test sets with a 80/20 split. This split was chosen by default as a good practice. This will leave us with 191 observations in the training set as well as 52 in the test set. Due to the small nature of the dataset at hand we will later apply cross validation in order to further examine the performance of our models and compare them with each other.


```{r}

set.seed(6)
split <- sample.split(df_scaled, SplitRatio=0.8)

train_set <- subset(df_scaled, split == "TRUE")
test_set <- subset(df_scaled, split=="FALSE")

dim(train_set)
dim(test_set)

```

### Logistic Regression

Logistic Regression is considered to be an extension of Linear Regression, in which we predict the qualitative response for an observation. It gives us the probability of a certain observation belonging to a class in binomial classification, but can also be extended to be used for multiple classifications.


#### Training the model

We first start by fitting our model on the training set. 

```{r}
logistic_model <- glm(Classes ~ Temperature+Rain+FFMC+DMC+DC+ISI+BUI+FWI+RH, data=train_set, family="binomial")

logistic_model
```

[Interpretation on the coefficients]

#### Testing the model

Since logistic regression gives us the probability of each observation belonging to the 1 class, we will use a 0.5 threshold to transform that probability into a classification of either 0 or 1.

After getting our predictions, we will use the confusion matrix function from the caret library that computes a set of performance matrices including f1-score, recall and precision. Other matrices computed include: sensitivity, specificity, prevalence etc. The official documentation for this function and the formulas for all matrices are found in this [link.](https://rdrr.io/cran/caret/man/confusionMatrix.html) We will only be interested in the f1-score, recall, precision, accuracy and balanced accuracy.

##### On the train set


```{r}
preds_logistic <- predict(logistic_model, train_set, type="response")

preds_logistic <- ifelse(preds_logistic >0.5,1,0)
preds_logistic <- as.factor(preds_logistic)

confusionMatrix(preds_logistic, train_set$Classes,
                mode = "everything",
                positive="1")
```


##### On the test set

```{r}
preds_logistic <- predict(logistic_model, test_set, type="response")

preds_logistic <- ifelse(preds_logistic >0.5,1,0)
preds_logistic <- as.factor(preds_logistic)

confusionMatrix(preds_logistic, test_set$Classes,
                mode = "everything",
                positive="1")
```

#### Plotting the ROC curve

As we plot the ROC curve, we can see that the AUC is equal to 0.986 which is almost a perfect classifier. Due to the small size of the dataset we have at hand we cannot make any conclusions yet until we try out the different other statistical learning methods.

```{r}
ROCPred <- prediction(as.numeric(preds_logistic), test_set$Classes)

ROCPer <- performance(ROCPred, measure="tpr",x.measure="fpr")
auc <- performance(ROCPred, measure = "auc")
auc <- auc@y.values[[1]]
auc
plot(ROCPer, colorize = TRUE)
```

#### Observations

Our statistics show the following:

1. On the training set: Accuracy is 100%, F1 score is 100%, with one False Negative and no False Positives.
2. On the testing set: Accuracy is 98%, F1 score is 98.6%, with one False Negative and no False Positives.

### LDA

Linear Discriminant Analysis is best used when the decision boundary of our given dataset is assumed to be linear. There are two basic assumptions that LDA takes into consideration:

1. There is a common variance across all response classes
2. The distribution of observations in each response class is normal with a **class-specific** mean, and a **common** variance


Since LDA assumes that each input variable has the same variance, we will use the standardized data-frame in the train test splits. Each variable in the standardized data-frame has mean of 0 and variance of 1.

#### Training the model


```{r}
lda_model = lda(Classes ~ Temperature+Rain+FFMC+DMC+DC+ISI+BUI+FWI+RH, data=train_set, family="binomial")
lda_model
```


[Interpretation on the coefficients]

#### Testing the model

##### On the train set

On our trainng data, the model reached an accuracy of 94.2% and an F1 score of 94.4%. 

```{r}
preds_lda = predict(lda_model,train_set, type="response")
confusionMatrix(preds_lda$class, train_set$Classes,
                mode = "everything",
                positive="1")
```

##### On the test set

As we can see below, our the number of false positives is 0, and the number of false negatives is 1. The results are very good but the other way around would have been better as we do not want to miss any positives meaning we want to predict all fires. Our model yielded an f1-score of 98.6% and an accuracy of 98%.

```{r}
preds_lda = predict(lda_model,test_set, type="response")
confusionMatrix(preds_lda$class, test_set$Classes,
                mode = "everything",
                positive="1")
```
#### Potting the ROC curve

The AUC for LDA was also 0.986, similar to the one for Logistic Regression.

```{r}
ROCPred <- prediction(as.numeric(preds_lda$class), test_set$Classes)
ROCPer <- performance(ROCPred, measure="tpr",x.measure="fpr")
auc <- performance(ROCPred, measure = "auc")
auc <- auc@y.values[[1]]
auc
plot(ROCPer, colorize = TRUE)
```

[INTERPRETATION]

### QDA

Quadratic Discriminant Analysis is best used when the decision boundary of our given dataset is assumed to be non-linear. Similarly to LDA, QDA makes two basic assumptions: 

1. There is a different covariance for each of the response classes
2. The distribution of observations in each response class is normal with a **class-specific** mean, and a **class-specific** covariance


#### Training the model


```{r}
qda_model = qda(Classes ~ Temperature+Rain+FFMC+DMC+DC+ISI+BUI+FWI+RH, data=train_set)
qda_model
```

[Interpretation on the coefficients]

#### Testing the model

##### On the train set

Our model yields an accuracy of 97.9% and an F1 score of 98% on the training set.

```{r}
preds_qda = predict(qda_model,train_set, type="response")
confusionMatrix(preds$class, train_set$Classes,
                mode = "everything",
                positive="1")
```

##### On the test set

As we can see below, our the number of false positives is 1, and the number of false negatives is 1. The results are very good but the other way around would have been better as we do not want to miss any positives meaning we want to predict all fires. Our model yielded an f1-score of 97.3% and an accuracy of 96%.  

```{r}
preds_qda = predict(qda_model,test_set, type="response")
confusionMatrix(preds_qda$class, test_set$Classes,
                mode = "everything",
                positive="1")
```

#### Potting the ROC curve

After plotting the ROC curve we got an AUC of 0.953, which is a bit worse than the one in Logistic Regression and LDA.

```{r}

ROCPred <- prediction(as.numeric(preds_qda$class), test_set$Classes)
ROCPer <- performance(ROCPred, measure="tpr",x.measure="fpr")
auc <- performance(ROCPred, measure = "auc")
auc <- auc@y.values[[1]]
auc
plot(ROCPer, colorize = TRUE)
```


### KNN Classifier
In this section, we will explore KNN's performance on our problem. We will use hyper parameter tuning to determine the best number of nearest numbers (K) and we will also use repeated cross validation in our training for better performance estimation. 

Since KNN is a distance based model, we will here again use our normalized dataset instead of the original. Once again the scaling technique used was the standard scaling using the function scale(). 

#### Training the model

##### Setting up the Cross-Validation for Hyperparameter tuning

The summaryFunction argument determines which metric to use to determine the performance of a particular hyperparameter setting. Here we shall use defaultSummary which calculates accuracy and kappa statistic. 

We have opted to go with the repeated 10 fold cross-validation method repeated 10 times. ClassProbs parameter is set to TRUE and we can set the threshold later when we test our model performance.

```{r}
training_control <- trainControl(method = "repeatedcv",
                                 summaryFunction = defaultSummary,
                                 classProbs = TRUE,
                                 number = 10,
                                 repeats = 10)
```

##### Training with Cross-validation

Now we use the train() function to perform the model training/tuning of the k hyper-parameter.
The range of k is from 3 to 85 in steps of 2 meaning we will only have odd values of k only as it is best practice for the KNN clustering.

Another tweak that we need to make on our data-set is to change our target variable values to valid R variable names in order for the KNN algorithm to work with class Probabilities as each values of our target variable will become a variable with its own probability values. Leaving the values as {0,1} will throw an error at us, therefore we will set our Classes variable values back to 'Fire' and 'Not_Fire' and proceed. 

```{r}
train_set$Classes <- mapvalues(train_set$Classes, from=c(0,1), to=c("not_fire","fire"))
test_set$Classes <- mapvalues(test_set$Classes, from=c(0,1), to=c("not_fire","fire"))

```

```{r}
knn_cv <- train(Classes ~ Temperature+Rain+FFMC+DMC+DC+ISI+BUI+FWI+RH, 
                data = train_set,
                method = "knn",
                trControl = training_control,
                metric = "Accuracy",
                tuneGrid = data.frame(k = seq(3, 85, by = 2)))
knn_cv
```

##### Distribution of predicted probabilites -threshold inspection-

Inspecting the probabilities reveals that a cutoff probability around 0.5 give good classification results.
```{r}
preds = predict(knn_cv,train_set, type = "prob")
train_set %>%
  ggplot() +
  aes(x = preds$fire, fill = Classes) +
  geom_histogram(bins = 20) +
  labs(x = "Probability", y = "Count", title = "Distribution of predicted probabilities for value fire" )
```

##### Plotting the training ROC curve

```{r}
pROC_train <- roc(response = train_set$Classes, predictor = preds[,"fire"],
                quiet = TRUE,
                plot = TRUE, 
                percent = TRUE,
                auc.polygon = TRUE, 
                print.auc = TRUE, 
                print.thres = TRUE,
                print.thres.best.method = "youden")
```

#### Testing the model

```{r}
preds = predict(knn_cv,test_set, type="raw")
confusionMatrix(preds, test_set$Classes,
                mode = "everything",
                positive="fire")
```

#### Potting the ROC curve on Test results

```{r}
preds <- as.vector(preds, mode = "numeric")
test_set$Classes <- as.vector(test_set$Classes, mode = "numeric")

pred <- prediction(preds, test_set$Classes) 

perf <- performance(pred,"tpr","fpr")
plot(perf,colorize=TRUE)
```
 
### Ensemble Methods / Tree based methods

#### Simple Decision Trees and tree pruning

The goal of ensemble modeling is to improve performance over a baseline model by combining multiple models. So, we will set the baseline performance measure by starting with one algorithm. In our case, we will build a simple decision tree.

Decision trees are widely used classifiers in industries based on their transparency in describing rules that lead to a prediction. They are arranged in a hierarchical tree-like structure and are simple to understand and interpret. They are not susceptible to outliers and are able to capture nonlinear relationships.

We will be using the rpart library for creating decision trees. rpart stands for recursive partitioning and employs the CART (classification and regression trees) algorithm. Apart from the rpart library, there are many other decision tree libraries like C50, Party, Tree, and mapTree.

```{r, results='hide'}
library(rpart)
library(rpart.plot)
```


##### Training the model with Pruning
Next, we create a decision tree model by calling the rpart function. Let's first create a base model with default parameters and value. 

Prepruning is also known as early stopping criteria. As the name suggests, the criteria are set as parameter values while building the rpart model. Below are some of the pre-pruning criteria that can be used. The tree stops growing when it meets any of these pre-pruning criteria, or it discovers the pure classes.

The complexity parameter (cp) in rpart is the minimum improvement in the model needed at each node. It’s based on the cost complexity of the model and works as follows: 

- For the given tree, add up the misclassification at every terminal node.
- Then multiply the number of splits time a penalty term (lambda) and add it to the total misclassification.
- The lambda is determined through cross-validation and not reported in R.
- The cp we see using printcp() is the scaled version of lambda over the misclassifcation rate of the overall data.

The cp value is a stopping parameter. It helps speed up the search for splits because it can identify splits that don’t meet this criteria and prune them before going too far.

Other parameters include but are not limited to: 

- maxdepth: This parameter is used to set the maximum depth of a tree. In this prepruning step.

- minsplit: It is the minimum number of records that must exist in a node for a split to happen or be attempted.

And one last thing, since we are in a classification setting, we have to specify class as the method used for building our tree instead of 'anova' that is used in regression settings. 

```{r}
base_model <- rpart(Classes ~ Temperature+Rain+FFMC+DMC+DC+ISI+BUI+FWI+RH, data = train_set, method = "class",  control = rpart.control(cp = 0, maxdepth = 8, minsplit = 8))
summary(base_model)
#Plot Decision Tree
rpart.plot(base_model)
```

The summary of our base model will give us the details of each split with the number of observations, the value of the complexity parameter, the predicted class, the class counts with their probabilites and the children of the node. It will also give details about the future splits starting with the primary splits that will follow and the percent improvement in the prediction as well as the surrogate splits that come later on. 

The resulting tree as explained in the above section, is the smallest tree with the lowest miss-classification loss. This tree is plotted with the split details and leaf node classes. 

The optimal CP value found was 0.96341463.

```{r}
preds = predict(base_model,train_set, type="class")
confusionMatrix(preds, train_set$Classes,
                mode = "everything",
                positive='1')
```
The train accuracy of our tree is 99% with an F1 score of 99% as well with a total of 2 misclassifications, 1 FP and 1 FN.  

##### Testing the model

We have a 100% accuracy on our held-out validation set which means we have successfully avoided overfitting using tree pruning. 

```{r}
preds = predict(base_model,test_set, type="class")
confusionMatrix(preds, test_set$Classes,
                mode = "everything",
                positive='1')
```

##### ROC curve

```{r}
preds <- as.vector(preds, mode = "numeric")
test_set$Classes <- as.vector(test_set$Classes, mode = "numeric")

pred <- prediction(preds, test_set$Classes) 

perf <- performance(pred,"tpr","fpr")
plot(perf,colorize=TRUE)
```

#### BAGGING

Bagging, or bootstrap aggregation, is an ensemble method that involves training the same algorithm many times by using different subsets sampled from the training data. The final output prediction is then averaged across the predictions of all the sub-models. The two most popular bagging ensemble techniques are Bagged Decision Trees and Random Forest.

##### Bagged Decision Trees

This method performs best with algorithms that have high variance. The argument method="treebag" specifies the algorithm. We will train our model using a 5-fold cross validation repeated 5 times. The sampling strategy used for the bagged trees is ROSE.

###### Training the model
```{r}
control <- trainControl(method="repeatedcv", number=5, repeats=5)

bagCART_model <- train(Classes ~ Temperature+Rain+FFMC+DMC+DC+ISI+BUI+FWI+RH, data=train_set, method="treebag", metric="Accuracy", trControl=control)
```
###### Training accuracy
```{r}
preds = predict(bagCART_model,train_set, type="raw")
confusionMatrix(preds, train_set$Classes,
                mode = "everything",
                positive='1')
```
###### Testing accuracy
```{r}
preds = predict(bagCART_model,test_set, type="raw")
confusionMatrix(preds, test_set$Classes,
                mode = "everything",
                positive='1')
```
##### Random Forests
Random Forest is an extension of bagged decision trees, where in addition to sampling the data, we also sample the variables in each bagged decision tree. The trees are constructed with the objective of reducing the correlation between the individual decision trees by making sure we do not use the same strong predictors in all bagged trees resulting in strongly correlated trees.

###### Training the model
```{r}
control <- trainControl(method="repeatedcv", number=5, repeats=5)

rf_model <- train(Classes ~ Temperature+Rain+FFMC+DMC+DC+ISI+BUI+FWI+RH, data=train_set, method="rf", metric="Accuracy", trControl=control)
```
###### Training accuracy
```{r}
preds = predict(rf_model,train_set, type="raw")
confusionMatrix(preds, train_set$Classes,
                mode = "everything",
                positive='1')
```
###### Testing accuracy
```{r}
preds = predict(rf_model,test_set, type="raw")
confusionMatrix(preds, test_set$Classes,
                mode = "everything",
                positive='1')
```

#### BOOSTING
In boosting, multiple models are trained sequentially and each model learns from the errors of its predecessors. We will use the Stochastic Gradient Boosting algorithm.

##### Stochastic Gradient Boosting
###### Training the model
```{r, results="hide"}
control <- trainControl(method="repeatedcv", number=5)

SGB <- train(Classes ~ Temperature+Rain+FFMC+DMC+DC+ISI+BUI+FWI+RH, data=train_set, method="gbm", metric="Accuracy", trControl=control)
```
###### Training accuracy
```{r}
preds = predict(SGB,train_set, type="raw")
confusionMatrix(preds, train_set$Classes,
                mode = "everything",
                positive='1')
```
###### Testing accuracy
```{r}
preds = predict(SGB,test_set, type="raw")
confusionMatrix(preds, test_set$Classes,
                mode = "everything",
                positive='1')
```
### SVM

Support Vector Machine is a discriminative classifier that classifies obserations using a hyperplane that best differentiates between the classes. Its advantages lay in the fact that they are very flexible and work well on high-dimensional data.

We will use SVM on our dataset to demonstrate its capabilities.

#### Training the model

The goal of the SVM is to identify a boundary that minimizes the total distance between the hyper-plane and the closest points on each class.

There are two hyper-parameters to take into consideration before training our SVM model: first, the cost *C* which acts as a regularization parameter and trades off correct classifications of the training examples against the maximization of the decision boundary. In other words, the greater the value of *C* the higher the number of errors occurring in the training classifications. The second hyper-parameter *gamma* defines how much curvature we want in our decision boundary. 

We start by tuning our model according to different values of *gamma* and *C*. We will start by using a linear kernel.

To use the cross validation functions from the [Caret](https://topepo.github.io/caret/train-models-by-tag.html#l1-regularization) package, we need to turn the 0/1 categorical values of the variable *Classes* into "fire"/"not_fire" (as required). The functions provided will allow us to find the best values for both *gamma* and *C*. we used a tuning length of 10.

```{r}
train_set$Classes <- mapvalues(train_set$Classes, from=c(0,1), to=c("not_fire","fire"))
test_set$Classes <- mapvalues(test_set$Classes, from=c(0,1), to=c("not_fire","fire"))
```

We perform repeated cross validation with 


```{r}
control = trainControl(method = "repeatedcv", repeats=5, summaryFunction=twoClassSummary, classProbs=TRUE)

svm_model_radial <- train(Classes ~ Temperature+Rain+FFMC+DMC+DC+ISI+BUI+FWI+RH, data =train_set, method="svmRadial", tuneLength=10, metric="ROC", trControl=control)

svm_model_linear <- train(Classes ~ Temperature+Rain+FFMC+DMC+DC+ISI+BUI+FWI+RH, data =train_set, method="svmLinear", tuneLength=10, metric="ROC", trControl=control)

svm_model_radial
svm_model_linear
```

As we can see above, the best values were found to be *sigma* = 0.2510562 and *C* = 16 for the radial kernel, and *C* = 1 for the linear kernel.

Using the radial kernel resulted in an *AUC* of 99% while the linear gave us an *AUC* of 99.8%.

NOTE: Even though the seed is set at 6, the values for *C* and *sigma* might change when trying to reproduce the experiment due to the dataset being small nd relatively non-complex. Still, the values for the AUC and accuracy will be still very high.

We will then proceed to show the confusion matrix of the model.

```{r}
preds_svm_train_linear <- predict(svm_model_linear, train_set)
preds_svm_train_radial <- predict(svm_model_radial, train_set)
  
confusionMatrix(preds_svm_train_linear,train_set$Classes, positive="fire")
confusionMatrix(preds_svm_train_radial,train_set$Classes, positive="fire")

preds_svm_test_linear <- predict(svm_model_linear, test_set)
preds_svm_test_radial <- predict(svm_model_radial, test_set)

confusionMatrix(preds_svm_test_linear,test_set$Classes, positive="fire")
confusionMatrix(preds_svm_test_radial,test_set$Classes, positive="fire")
```

For the radial kernel: our model gave us an accuracy of 100% on the training set and 96.15% on the test set.

For the linear kernel: the model gave an accuracy of 98.95% on the train set and performed worse than the radial kernel, which is expected since it is less flexible and fits the data less well. On the test set however, it gave us the same accuracy. 

Overall, since our focus would be to correctly classify fires, we will go with the radial kernel since it gave us a fewer number of false negatives than the linear one.

#### Plotting the ROC curve

```{r}

ROCPred <- prediction(as.numeric(preds_svm_test), as.numeric(test_set$Classes))
ROCPer <- performance(ROCPred, measure="tpr",x.measure="fpr")
auc <- performance(ROCPred, measure = "auc")
auc <- auc@y.values[[1]]
auc
plot(ROCPer, colorize = TRUE)
```

We get an AUC value of 0.953 using the SVM classifier.




